#include<stdio.h>
#include<stdlib.h>
#include<errno.h>
#include<string.h>
int main()
{
	int i = 0;
	int n = 0;
	scanf("%d", &n);
	int*p = (int*)malloc(n * sizeof(int)); //n * sizeof(int)
	//与int*p = (int*)realloc(NULL, n * sizeof(int));相同
	int*q = (int*)calloc(10, sizeof(int));//会初始空间存放0
	int*tmp=(int*)realloc(q, 20);//创建新的指针接收，防止失败后原数据丢失
	//扩大空间时，后续足够直接追加，不够开辟新的，再拷贝原数据并释放旧指针,直接缩小空间
	if (!p||!q||!tmp)//assert(...)
		printf("%s\n", strerror(errno));
	else
	{
		q = tmp;
		for (i = 0; i < n; i++)
		{
			*(p + i) = i;
			printf("%d ", *(p + i));
		}
	}
	free(p);
	free(q);
	p = NULL;//置为空指针，保证数据安全
	q = NULL;
	return 0;
}

#include<stdio.h>
#include<stdlib.h>
#include<string.h>
void G(char**ps)//void G(char*ps)
{
	*ps = (char*)malloc(40);
}
void test()
{
	char*str ="abcd";
	//G(str);错误，传值未传址,未free,没置为空指针，没判断是否申请成功
	G(&str);//注意传地址
	strcpy(str, "efgh");
	printf(str);
}
int*test1()
{
	static int a = 10;//int a = 10;放在栈区
	return &a;
}
struct NEW
{
	int n;
	int a[0];
};
struct NEW_P
{
	int*b;
};
int main()
{
	int *q = test1();//非法修改局部变量的值.将局部变量设置在静态区后可
	*q = 1;
	printf("%d\n",*q);
	test();
	struct NEW*p1 = (struct NEW*)malloc(sizeof(struct NEW) + 5 * sizeof(int));//柔性数组
	struct NEW_P*p2 = (struct NEW_P*)malloc(40);//指针可变大小数组，一般要申请两次空间，使数据的存储不连续，降低读取效率，也要释放两次
	p2->b = (int*)malloc(20);
	int i = 0;
	for (i = 0; i < 5; i++)
	{
		p1->a[i] = i;
		printf("%d ", p1->a[i]);
	}
	printf("\n");
	for (i = 0; i < 5; i++)
	{
		p2->b[i] = i;
		printf("%d ", p2->b[i]);
	}
	printf("\n");
	free(p1);
	p1 = NULL;
	free(p2->b);
	free(p2);
	p2->b = NULL;
	p2 = NULL;
	return 0;
}

#include<stdio.h>
#include<string.h>
int main()
{
	int a = 12345;
	char b[2] = "ha";
	char c[2] = { 0 };
	char buf[9999] = { 0 };
	FILE*p1 = fopen("1.txt", "wb");
	FILE*p2 = fopen("./2.txt", "a");//./相对路径，只在当前文件夹，../指在上一级文件夹
	FILE*p3 = fopen("../3.txt", "a");//D:\编程\学习\txt.3
	FILE*p4 = fopen("C:\\Users\\马县杨\\Desktop\\21011111 马县杨.txt", "r");
	if (!p1 || !p2 || !p3||!p4)
	{
		printf("%s\n", strerror(errno));
		return 0;
	}
	fwrite(&a, 4, 1, p1);
	fwrite(&b[0], 1, 1, p2);
	fwrite(&b[1], 1, 1, p3);
	/*fgets(buf, 99999, p4);//单行打印读取
	fputs(buf, stdout);*/
	for (int i = 0; i < 9999; i++)
	{
		fscanf(p4, "%c", &buf[i]);
		printf("%c", buf[i]);
	}
	sprintf(c, "%c%c", b[0], b[1]);//将b中数据传给c，格式化的形式写入数据
	sscanf(b,"%c%c", &c[0], &c[1]);//格式化输入,将b中的数据赋给c
	fputc(fgetc(stdin),stdout);//stdin输入流，stdout输出流
	fclose(p1);
	fclose(p2);
	fclose(p3);
	fclose(p4);
	p1 = NULL;
	p2 = NULL;
	p3 = NULL;
	p4 = NULL;
	return 0;
}
